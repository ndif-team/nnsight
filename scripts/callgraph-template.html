<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>nnsight Source Serialization Call Graph Evolution</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #fff;
      color: #333;
      overflow: hidden;
    }
    #container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      height: 100dvh;
    }
    #header {
      padding: 12px 20px;
      background: #f5f5f5;
      border-bottom: 1px solid #ddd;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }
    h1 {
      font-size: 18px;
      font-weight: 500;
    }
    h1 a { color: inherit; text-decoration: none; }
    h1 a:hover { text-decoration: underline; }
    #stats {
      font-size: 14px;
      color: #666;
    }
    #graph-container {
      flex: 1;
      position: relative;
      min-height: 0;
      overflow: hidden;
    }
    svg {
      width: 100%;
      height: 100%;
    }
    .node {
      cursor: pointer;
    }
    .node circle, .node rect {
      stroke: #333;
      stroke-width: 1.5px;
      transition: r 0.3s ease;
    }
    .node.class circle {
      stroke-width: 2.5px;
    }
    .node.method circle {
      stroke-dasharray: 2,2;
    }
    .node.staticmethod circle, .node.classmethod circle {
      stroke-dasharray: 4,2;
    }
    .node.property circle {
      stroke-width: 1px;
    }
    .node.function rect {
      rx: 3;
      ry: 3;
    }
    .node.dead-code circle, .node.dead-code rect {
      stroke: #c00;
      stroke-width: 2px;
      opacity: 0.6;
    }
    .node.dead-code text {
      fill: #c00;
      font-style: italic;
    }
    .node text {
      font-size: 9px;
      fill: #333;
      pointer-events: none;
    }
    .node.new circle, .node.new rect {
      animation: pulse 0.5s ease-out;
      filter: drop-shadow(0 0 6px #22c55e) drop-shadow(0 0 12px #22c55e);
    }
    .node.new text {
      font-weight: bold;
    }
    .new-badge {
      font-size: 7px;
      font-weight: bold;
      fill: #fff;
      pointer-events: none;
    }
    .new-badge-bg {
      fill: #22c55e;
      rx: 2;
      ry: 2;
    }
    @keyframes pulse {
      0% { opacity: 0; transform: scale(0); }
      50% { opacity: 1; }
      100% { opacity: 1; transform: scale(1); }
    }
    @keyframes glow {
      0%, 100% { filter: drop-shadow(0 0 4px #22c55e) drop-shadow(0 0 8px #22c55e); }
      50% { filter: drop-shadow(0 0 8px #22c55e) drop-shadow(0 0 16px #22c55e); }
    }
    .node.new-glow circle, .node.new-glow rect {
      animation: glow 1.5s ease-in-out infinite;
    }
    .link {
      stroke: #666;
      stroke-opacity: 0.5;
      stroke-width: 1.5px;
      fill: none;
    }
    .link.extends {
      stroke: #e94560;
      stroke-width: 2px;
      stroke-opacity: 0.8;
    }
    .link.contains {
      stroke: #999;
      stroke-width: 1px;
      stroke-opacity: 0.3;
      stroke-dasharray: 2,4;
    }
    .link.new {
      animation: fadeIn 0.3s ease-out;
    }
    @keyframes fadeIn {
      from { stroke-opacity: 0; }
      to { stroke-opacity: 0.6; }
    }
    #controls {
      padding: 15px 20px;
      background: #f5f5f5;
      border-top: 1px solid #ddd;
      flex-shrink: 0;
    }
    #timeline-container {
      display: flex;
      align-items: center;
      gap: 15px;
    }
    #timeline {
      flex: 1;
      height: 8px;
      -webkit-appearance: none;
      background: #ddd;
      border-radius: 4px;
      outline: none;
    }
    #timeline::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: #3572A5;
      border-radius: 50%;
      cursor: pointer;
    }
    #play-btn {
      background: #3572A5;
      border: none;
      color: white;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      min-width: 80px;
    }
    #play-btn:hover {
      background: #4a8bc2;
    }
    #commit-info {
      margin-top: 10px;
      font-size: 13px;
      color: #666;
      display: flex;
      justify-content: space-between;
    }
    #date {
      color: #3572A5;
      font-weight: 500;
      cursor: pointer;
    }
    #date:hover { text-decoration: underline; }
    #message {
      flex: 1;
      margin-left: 20px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
    }
    #message:hover { text-decoration: underline; }
    #hash {
      cursor: pointer;
      font-family: monospace;
    }
    #hash:hover { text-decoration: underline; }
    .coauthor-icon {
      display: inline-block;
      width: 14px;
      height: 14px;
      margin-right: 4px;
      vertical-align: middle;
      opacity: 0.9;
    }
    .coauthor-icon svg {
      width: 100%;
      height: 100%;
    }
    .tooltip {
      position: absolute;
      background: rgba(240,240,240,0.95);
      color: #333;
      padding: 8px 12px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      max-width: 400px;
    }
    #search-box {
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      width: 180px;
      outline: none;
    }
    #search-box:focus {
      border-color: #3572A5;
      box-shadow: 0 0 0 2px rgba(53,114,165,0.2);
    }
    .search-highlight {
      fill: none;
      stroke: #3572A5;
      stroke-width: 3px;
      pointer-events: none;
    }
    @keyframes highlight-pulse {
      0%, 100% { stroke-opacity: 1; r: 20; }
      50% { stroke-opacity: 0.5; r: 25; }
    }
    .search-highlight.active {
      animation: highlight-pulse 1s ease-in-out infinite;
    }
    .decorator-badge {
      font-size: 10px;
      background: #e8e8e8;
      padding: 1px 4px;
      border-radius: 2px;
      margin-left: 4px;
    }
    .decorator-badge.remote { background: #d4edda; color: #155724; }
  </style>
</head>
<body>
  <div id="container">
    <div id="header">
      <h1>
        <a href="https://github.com/davidbau/nnsight">nnsight</a>
        <a href="https://github.com/davidbau/nnsight/tree/source-serialization-design/src/nnsight/intervention">Source Serialization</a>
        Call Graph Evolution
        <a href="https://github.com/davidbau/nnsight#readme" title="View on GitHub">
          <svg viewBox="0 0 512 512" style="width:14px;height:14px;vertical-align:-1px">
            <circle cx="256" cy="256" r="256" fill="#181717"/>
            <path fill="#fff" d="M335 499c-13 0-16-6-16-12l1-70c0-24-8-40-18-48 57-6 117-28 117-126 0-28-10-51-26-69 3-6 11-32-3-67 0 0-21-7-70 26-42-12-86-12-128 0-49-33-70-26-70-26-14 35-6 61-3 67-16 18-26 41-26 69 0 98 59 120 116 126-7 7-14 18-16 35-15 6-52 17-74-22 0 0-14-24-40-26 0 0-25 0-1 16 0 0 16 7 28 37 0 0 15 50 86 34l1 44c0 6-3 12-16 12-14 0-12 17-12 17H347s2-17-12-17Z"/>
          </svg>
        </a>
      </h1>
      <input type="text" id="search-box" placeholder="Search function...">
      <div id="stats">Loading...</div>
    </div>
    <div id="graph-container">
      <svg></svg>
      <div class="tooltip"></div>
    </div>
    <div id="controls">
      <div id="timeline-container">
        <button id="play-btn">Play</button>
        <input type="range" id="timeline" min="0" max="100" value="0">
      </div>
      <div id="commit-info">
        <span id="date">-</span>
        <span id="message">-</span>
        <span id="hash">-</span>
      </div>
    </div>
  </div>

  <script>
    let timeline = [];
    let currentIndex = 0;
    let isPlaying = false;
    let playInterval = null;
    let simulation = null;
    let zoomBehavior = null;

    // Chunked loading
    let chunkManifest = null;
    let loadedChunks = new Map();
    let chunksRemaining = 0;

    // Configuration - Python uses different file structure
    const REPO_NAME = 'davidbau/nnsight';
    const BRANCH = 'source-serialization-design';

    // Claude badge for co-authored commits
    const claudeBadge = `<span class="coauthor-icon claude-icon" title="Co-authored with Claude">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="#D97706">
        <path d="m3.127 10.604 3.135-1.76.053-.153-.053-.085H6.11l-.525-.032-1.791-.048-1.554-.065-1.505-.08-.38-.081L0 7.832l.036-.234.32-.214.455.04 1.009.069 1.513.105 1.097.064 1.626.17h.259l.036-.105-.089-.065-.068-.064-1.566-1.062-1.695-1.121-.887-.646-.48-.327-.243-.306-.104-.67.435-.48.585.04.15.04.593.456 1.267.981 1.654 1.218.242.202.097-.068.012-.049-.109-.181-.9-1.626-.96-1.655-.428-.686-.113-.411a2 2 0 0 1-.068-.484l.496-.674L4.446 0l.662.089.279.242.411.94.666 1.48 1.033 2.014.302.597.162.553.06.17h.105v-.097l.085-1.134.157-1.392.154-1.792.052-.504.25-.605.497-.327.387.186.319.456-.045.294-.19 1.23-.37 1.93-.243 1.29h.142l.161-.16.654-.868 1.097-1.372.484-.545.565-.601.363-.287h.686l.505.751-.226.775-.707.895-.585.759-.839 1.13-.524.904.048.072.125-.012 1.897-.403 1.024-.186 1.223-.21.553.258.06.263-.218.536-1.307.323-1.533.307-2.284.54-.028.02.032.04 1.029.098.44.024h1.077l2.005.15.525.346.315.424-.053.323-.807.411-3.631-.863-.872-.218h-.12v.073l.726.71 1.331 1.202 1.667 1.55.084.383-.214.302-.226-.032-1.464-1.101-.565-.497-1.28-1.077h-.084v.113l.295.432 1.557 2.34.08.718-.112.234-.404.141-.444-.08-.911-1.28-.94-1.44-.759-1.291-.093.053-.448 4.821-.21.246-.484.186-.403-.307-.214-.496.214-.98.258-1.28.21-1.016.19-1.263.112-.42-.008-.028-.092.012-.953 1.307-1.448 1.957-1.146 1.227-.274.109-.477-.247.045-.44.266-.39 1.586-2.018.956-1.25.617-.723-.004-.105h-.036l-4.212 2.736-.75.096-.324-.302.04-.496.154-.162 1.267-.871z"/>
      </svg></span>`;

    const nodePositions = new Map();
    const colorScale = d3.scaleSequential(d3.interpolateViridis);
    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    const modifierHint = isMac ? 'âŒ˜-click' : 'Ctrl-click';

    function getIndexFromURL() {
      const hash = window.location.hash.slice(1);
      const params = new URLSearchParams(hash);
      if (params.has('i')) {
        const idx = parseInt(params.get('i'));
        if (idx >= 0 && idx < timeline.length) return idx;
      }
      if (params.has('c')) {
        const commitHash = params.get('c');
        const idx = timeline.findIndex(s => s.hash === commitHash || s.hash.startsWith(commitHash));
        if (idx >= 0) return idx;
      }
      return timeline.length - 1;
    }

    function shouldAutoPlay() {
      const hash = window.location.hash.slice(1);
      return hash === 'play' || hash.startsWith('play&') || hash.includes('&play');
    }

    function renderCoauthorBadges(snapshot) {
      const badges = [];
      if (snapshot.claudeCoauthored) badges.push(claudeBadge);
      return badges.join('');
    }

    function updateURL(index) {
      const hash = timeline[index]?.hash;
      if (hash) {
        history.replaceState(null, '', `#c=${hash}`);
      }
    }

    function loadCallgraphManifest(manifest) {
      chunkManifest = manifest;
      chunksRemaining = manifest.chunkCount;
      document.getElementById('stats').textContent = `Loading ${manifest.chunkCount} data files...`;

      manifest.files.forEach((filename, index) => {
        const script = document.createElement('script');
        script.src = filename;
        script.onerror = () => {
          document.getElementById('stats').textContent = `Error loading ${filename}`;
        };
        document.head.appendChild(script);
      });
    }

    function loadCallgraphChunk(chunkIndex, data) {
      loadedChunks.set(chunkIndex, data);
      chunksRemaining--;

      const loaded = chunkManifest.chunkCount - chunksRemaining;
      document.getElementById('stats').textContent = `Loading ${loaded}/${chunkManifest.chunkCount} data files...`;

      if (chunksRemaining === 0) {
        timeline = [];
        for (let i = 0; i < chunkManifest.chunkCount; i++) {
          const chunk = loadedChunks.get(i);
          if (chunk) timeline.push(...chunk);
        }
        loadedChunks.clear();
        requestAnimationFrame(() => requestAnimationFrame(() => initWithData()));
      }
    }

    function loadCallgraphData(data) {
      timeline = data;
      requestAnimationFrame(() => requestAnimationFrame(() => initWithData()));
    }

    function initWithData() {
      if (timeline.length === 0) {
        document.getElementById('stats').textContent = 'No data found';
        return;
      }

      const nodeFirstSeen = new Map();
      timeline.forEach((snapshot, idx) => {
        snapshot.nodes.forEach(node => {
          if (!nodeFirstSeen.has(node.id)) {
            nodeFirstSeen.set(node.id, idx);
          }
        });
      });

      timeline.forEach(snapshot => {
        snapshot.nodes.forEach(node => {
          node.firstSeen = nodeFirstSeen.get(node.id);
        });
      });

      const slider = document.getElementById('timeline');
      slider.max = timeline.length - 1;
      slider.addEventListener('input', (e) => {
        currentIndex = parseInt(e.target.value);
        updateGraph(currentIndex);
        updateURL(currentIndex);
      });

      document.getElementById('play-btn').addEventListener('click', togglePlay);

      document.getElementById('hash').addEventListener('click', () => {
        const hash = timeline[currentIndex]?.hash;
        if (hash) window.open(`https://github.com/${REPO_NAME}/commit/${hash}`, '_blank');
      });
      document.getElementById('message').addEventListener('click', () => {
        const hash = timeline[currentIndex]?.hash;
        if (hash) window.open(`https://github.com/${REPO_NAME}/commit/${hash}`, '_blank');
      });

      setupSVG();

      const autoPlay = shouldAutoPlay();
      currentIndex = autoPlay ? 0 : getIndexFromURL();
      slider.value = currentIndex;
      updateGraph(currentIndex);

      if (autoPlay) {
        setTimeout(togglePlay, 100);
      }
    }

    function setupSVG() {
      const container = document.getElementById('graph-container');
      const width = container.clientWidth;
      const height = container.clientHeight;

      const svg = d3.select('#graph-container svg')
        .attr('viewBox', [-width / 2, -height / 2, width, height]);

      const g = svg.append('g');
      zoomBehavior = d3.zoom()
        .scaleExtent([0.1, 4])
        .on('zoom', (event) => g.attr('transform', event.transform));
      svg.call(zoomBehavior);

      svg.append('defs').append('marker')
        .attr('id', 'arrowhead')
        .attr('viewBox', '-0 -5 10 10')
        .attr('refX', 16)
        .attr('refY', 0)
        .attr('orient', 'auto')
        .attr('markerWidth', 5)
        .attr('markerHeight', 5)
        .append('path')
        .attr('d', 'M 0,-5 L 10,0 L 0,5')
        .attr('fill', '#666');

      g.append('g').attr('class', 'links');
      g.append('g').attr('class', 'nodes');

      const aspectRatio = width / height;
      const totalStrength = 0.09;
      const xStrength = totalStrength / (1 + aspectRatio);
      const yStrength = totalStrength * aspectRatio / (1 + aspectRatio);

      simulation = d3.forceSimulation()
        .force('link', d3.forceLink().id(d => d.id).distance(50).strength(d => Math.min(1, 3 / (Math.max(d.source.degree || 1, d.target.degree || 1) + 1))))
        .force('charge', d3.forceManyBody().strength(-80))
        .force('center', d3.forceCenter(0, 0))
        .force('x', d3.forceX(0).strength(xStrength))
        .force('y', d3.forceY(0).strength(yStrength))
        .force('collision', d3.forceCollide().radius(15))
        .alphaDecay(0.01)
        .velocityDecay(0.3);
    }

    function updateGraph(index) {
      const snapshot = timeline[index];
      if (!snapshot) return;

      const container = document.getElementById('graph-container');
      const width = container.clientWidth;
      const height = container.clientHeight;

      // Update stats
      const classCount = snapshot.nodes.filter(n => n.type === 'class').length;
      const methodCount = snapshot.nodes.filter(n => ['method', 'staticmethod', 'classmethod', 'property'].includes(n.type)).length;
      const funcCount = snapshot.nodes.filter(n => n.type === 'function').length;
      const lineCount = snapshot.lineCount || 0;
      const testCount = snapshot.testCount || 0;

      const parts = [`${lineCount.toLocaleString()} lines`];
      if (classCount > 0) parts.push(`${classCount} classes`);
      if (methodCount > 0) parts.push(`${methodCount} methods`);
      if (funcCount > 0) parts.push(`${funcCount} functions`);
      if (testCount > 0) parts.push(`${testCount} tests`);
      document.getElementById('stats').textContent = parts.join(', ');
      document.getElementById('date').textContent = snapshot.date;

      const msgEl = document.getElementById('message');
      const escaped = snapshot.message.replace(/</g, '&lt;').replace(/>/g, '&gt;');
      msgEl.innerHTML = renderCoauthorBadges(snapshot) + escaped;
      document.getElementById('hash').textContent = snapshot.hash;

      const svg = d3.select('#graph-container svg');
      const g = svg.select('g');

      // Save positions
      if (simulation) {
        simulation.nodes().forEach(n => {
          if (n.x !== undefined && n.y !== undefined) {
            nodePositions.set(n.id, { x: n.x, y: n.y });
          }
        });
      }

      // Calculate degree
      const degree = new Map();
      snapshot.edges.forEach(e => {
        degree.set(e.source, (degree.get(e.source) || 0) + 1);
        degree.set(e.target, (degree.get(e.target) || 0) + 1);
      });

      // Prepare nodes
      const nodes = snapshot.nodes.map(n => {
        const pos = nodePositions.get(n.id);
        const isNew = n.firstSeen === index;
        const nodeData = { ...n, isNew, degree: degree.get(n.id) || 0 };

        if (pos) {
          return { ...nodeData, x: pos.x, y: pos.y, fx: pos.x, fy: pos.y };
        } else {
          return {
            ...nodeData,
            x: (Math.random() - 0.5) * 100,
            y: (Math.random() - 0.5) * 100
          };
        }
      });

      const edges = snapshot.edges.map(e => ({
        source: e.source,
        target: e.target,
        type: e.type || 'calls'
      }));

      // Add contains links for methods
      const nodeIds = new Set(nodes.map(n => n.id));
      nodes.forEach(n => {
        if (['method', 'staticmethod', 'classmethod', 'property'].includes(n.type) && n.id.includes('.')) {
          const className = n.id.split('.')[0];
          if (nodeIds.has(className)) {
            edges.push({ source: className, target: n.id, type: 'contains' });
          }
        }
      });

      setTimeout(() => {
        nodes.forEach(n => { n.fx = null; n.fy = null; });
        simulation.alpha(0.5).restart();
      }, 100);

      const maxIdx = index || 1;

      // Update links
      const link = g.select('.links')
        .selectAll('path')
        .data(edges, d => `${d.source}-${d.target}`);

      link.exit().remove();

      const linkEnter = link.enter()
        .append('path')
        .attr('class', d => 'link new ' + (d.type || 'calls'))
        .attr('marker-end', d => d.type === 'contains' ? null : 'url(#arrowhead)');

      const linkMerge = linkEnter.merge(link).classed('new', false);

      // Update nodes
      const node = g.select('.nodes')
        .selectAll('.node')
        .data(nodes, d => d.id);

      node.exit().remove();

      const nodeEnter = node.enter()
        .append('g')
        .attr('class', d => 'node ' + (d.type || 'function') + (d.isNew ? ' new' : ''))
        .call(d3.drag()
          .on('start', dragstarted)
          .on('drag', dragged)
          .on('end', dragended));

      // Classes get circles, functions get rectangles
      nodeEnter.each(function(d) {
        const g = d3.select(this);
        if (d.type === 'class') {
          g.append('circle').attr('r', 10);
        } else if (d.type === 'function') {
          g.append('rect').attr('width', 12).attr('height', 12).attr('x', -6).attr('y', -6);
        } else {
          // Methods get smaller circles
          g.append('circle').attr('r', 6);
        }
      });

      nodeEnter.append('text').attr('dx', 12).attr('dy', 3);

      // Add NEW badge for newly introduced nodes
      nodeEnter.filter(d => d.isNew).each(function(d) {
        const g = d3.select(this);
        const badge = g.append('g').attr('class', 'new-badge-group').attr('transform', 'translate(-8, -14)');
        badge.append('rect').attr('class', 'new-badge-bg').attr('width', 22).attr('height', 10).attr('x', 0).attr('y', 0);
        badge.append('text').attr('class', 'new-badge').attr('x', 11).attr('y', 8).attr('text-anchor', 'middle').text('NEW');
      });

      const nodeMerge = nodeEnter.merge(node);

      nodeMerge.select('circle, rect')
        .attr('fill', d => {
          const t = d.firstSeen / maxIdx;
          return d3.interpolateTurbo(0.15 + t * 0.7);
        });

      nodeMerge.select('text')
        .text(d => {
          let label = d.type === 'method' && d.id.includes('.') ? d.id.split('.').pop() : d.id;
          return label.length > 25 ? label.slice(0, 25) + '...' : label;
        });

      // Update simulation
      const forceScale = Math.max(0.33, Math.min(1, nodes.length / 200));
      const collisionRadius = 15 + 30 * (1 - forceScale);
      const aspectRatio = width / height;
      const totalStrength = 0.09;
      const xStrength = totalStrength / (1 + aspectRatio);
      const yStrength = totalStrength * aspectRatio / (1 + aspectRatio);

      simulation.force('charge').strength(-80);
      simulation.force('x').x(0).strength(xStrength);
      simulation.force('y').y(0).strength(yStrength);
      simulation.force('collision').radius(collisionRadius);

      simulation.nodes(nodes);
      simulation.force('link').links(edges);
      simulation.alpha(0.3).restart();

      simulation.on('tick', () => {
        linkMerge.attr('d', d => {
          if (d.source.id === d.target.id) {
            const x = d.source.x;
            const y = d.source.y;
            return `M${x},${y} C${x-30},${y-25} ${x-30},${y+25} ${x},${y}`;
          }
          return `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`;
        });

        nodeMerge.attr('transform', d => `translate(${d.x},${d.y})`);

        simulation.nodes().forEach(n => {
          if (n.x !== undefined && n.y !== undefined) {
            nodePositions.set(n.id, { x: n.x, y: n.y });
          }
        });
      });

      // Tooltips
      const tooltip = d3.select('.tooltip');
      nodeMerge
        .on('mouseover', (event, d) => {
          let decoratorHtml = '';
          if (d.decorators && d.decorators.length > 0) {
            decoratorHtml = '<br>Decorators: ' + d.decorators.map(dec =>
              `<span class="decorator-badge ${dec === 'remote' ? 'remote' : ''}">${dec}</span>`
            ).join('');
          }
          tooltip
            .style('opacity', 1)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 10) + 'px')
            .html(`<strong>${d.id}</strong><br>Type: ${d.type || 'function'}` +
                  (d.file ? `<br>File: ${d.file.split('/').pop()}` : '') +
                  decoratorHtml +
                  `<br>Added: ${timeline[d.firstSeen]?.date || 'unknown'}` +
                  (d.line ? `<br>Lines: ${d.line}-${d.endLine}` : '') +
                  `<br><em>${modifierHint} to view on GitHub</em>`);
        })
        .on('mouseout', () => tooltip.style('opacity', 0))
        .on('click', (event, d) => {
          if (event.metaKey || event.ctrlKey) {
            event.preventDefault();
            const hash = snapshot.hash;
            const file = d.file || 'src/nnsight/intervention/serialization_source.py';
            const lineRange = d.line && d.endLine ? `#L${d.line}-L${d.endLine}` : '';
            const url = `https://github.com/${REPO_NAME}/blob/${BRANCH}/${file}${lineRange}`;
            window.open(url, '_blank');
          }
        });
    }

    function togglePlay() {
      const btn = document.getElementById('play-btn');
      const slider = document.getElementById('timeline');

      if (isPlaying) {
        isPlaying = false;
        btn.textContent = 'Play';
        clearInterval(playInterval);
        updateURL(currentIndex);
      } else {
        isPlaying = true;
        btn.textContent = 'Pause';

        if (currentIndex >= timeline.length - 1) {
          currentIndex = 0;
        }

        playInterval = setInterval(() => {
          currentIndex++;
          if (currentIndex >= timeline.length) {
            currentIndex = timeline.length - 1;
            updateURL(currentIndex);
            togglePlay();
            return;
          }
          slider.value = currentIndex;
          updateGraph(currentIndex);
        }, 200);
      }
    }

    function dragstarted(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }

    function dragended(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }

    function handleResize() {
      const container = document.getElementById('graph-container');
      const width = container.clientWidth;
      const height = container.clientHeight;
      if (width === 0 || height === 0) return;

      d3.select('#graph-container svg').attr('viewBox', [-width / 2, -height / 2, width, height]);

      const aspectRatio = width / height;
      const totalStrength = 0.09;
      const xStrength = totalStrength / (1 + aspectRatio);
      const yStrength = totalStrength * aspectRatio / (1 + aspectRatio);

      simulation.force('x').strength(xStrength);
      simulation.force('y').strength(yStrength);
      simulation.alpha(0.1).restart();
    }

    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', () => setTimeout(handleResize, 100));

    // Search
    const searchBox = document.getElementById('search-box');
    let highlightCircle = null;
    let currentHighlightNode = null;

    function highlightNode(searchTerm) {
      if (highlightCircle) {
        highlightCircle.remove();
        highlightCircle = null;
        currentHighlightNode = null;
      }

      if (!searchTerm || !searchTerm.trim()) return;

      const term = searchTerm.trim().toLowerCase();
      const snapshot = timeline[currentIndex];
      if (!snapshot) return;

      let matchingNode = null;
      let bestScore = -1;
      let bestLength = Infinity;

      for (const n of snapshot.nodes) {
        const id = n.id.toLowerCase();
        let score = -1;

        if (id === term) score = 3;
        else if (id.startsWith(term)) score = 2;
        else if (id.includes(term)) score = 1;

        if (score > bestScore || (score === bestScore && score > 0 && n.id.length < bestLength)) {
          bestScore = score;
          bestLength = n.id.length;
          matchingNode = n;
        }
      }

      if (matchingNode && nodePositions.has(matchingNode.id)) {
        const pos = nodePositions.get(matchingNode.id);
        currentHighlightNode = matchingNode.id;

        const g = d3.select('svg g');
        highlightCircle = g.insert('circle', ':first-child')
          .attr('class', 'search-highlight active')
          .attr('cx', pos.x)
          .attr('cy', pos.y)
          .attr('r', 25);

        const svg = d3.select('svg');
        const width = svg.node().clientWidth;
        const height = svg.node().clientHeight;
        const scale = 1.5;
        const transform = d3.zoomIdentity
          .translate(width / 2, height / 2)
          .scale(scale)
          .translate(-pos.x, -pos.y);

        svg.transition().duration(500).call(zoomBehavior.transform, transform);
      }
    }

    searchBox.addEventListener('input', (e) => highlightNode(e.target.value));

    searchBox.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        searchBox.value = '';
        highlightNode('');
        searchBox.blur();
      }
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === '/' && document.activeElement !== searchBox) {
        e.preventDefault();
        searchBox.focus();
        searchBox.select();
      }
    });
  </script>
  <script src="callgraph-manifest.js" onerror="document.getElementById('stats').textContent='Run: python scripts/build-callgraph.py'"></script>
</body>
</html>
